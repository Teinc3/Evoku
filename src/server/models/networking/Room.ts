import MatchHandler from "../../handlers/match";

import type { UUID } from "crypto";
import type IPlayerState from "@shared/types/gamestate";
import type MatchActions from "@shared/types/enums/actions/match";
import type ActionMap from "@shared/types/actionmap";
import type IDataHandler from "../../types/handler";
import type BroadcastOptions from "../../types/broadcast";
import type SessionModel from "./Session";


/**
 * A model representing a room in the game.
 */
export default class RoomModel {
  public roomDataHandler: IDataHandler<MatchActions>
  public participants: Map<UUID, SessionModel>
  public playerMap: Map<UUID, number>;
  private playerStates: Map<number, IPlayerState>;
  private playerIDCounter: number;
    
  constructor(
    public readonly roomID: string, // Should be generated by RoomManager
  ) {
    this.roomDataHandler = new MatchHandler(this);
    this.participants = new Map();
    this.playerStates = new Map();
    this.playerMap = new Map();
    this.playerIDCounter = 0;
  }

  /**
   * Assigns sessions to the room as players.
   * @param sessions The sessions to add to the room, as players.
   */
  public addPlayers(sessions: SessionModel[]): void {
    sessions.forEach(session => {
      // Assign session reference
      this.participants.set(session.uuid, session);
      session.room = this;

      // Create playerID as key
      const playerID = this.playerIDCounter++;
      this.playerStates.set(playerID, { playerID });
      this.playerMap.set(session.uuid, playerID);
    });
  }

  /**
   * Removes a session from the room.
   * @param session The session to remove from the room.
   */
  public removeSession(session: SessionModel): void {
    this.participants.delete(session.uuid);
    session.room = null; // Dereference the room from the session

    // Might have to check for / clear game state, and invoke lifecycles
    // We do not remove the state, as it might be needed for history (like after a game ends)
    this.playerMap.delete(session.uuid);

  }

  /**
   * Broadcasts data to all sessions in the room.
   * @param action The action to broadcast.
   * @param data The data to send with the action.
   * @optional @param excludeSessions Filter out sessions that should not receive the broadcast.
   */
  public broadcast<GenericAction extends MatchActions>(
    action: GenericAction,
    data: ActionMap[GenericAction],
    options: BroadcastOptions = {}
  ) {
    const { to = 'all', exclude = new Set() } = options;
    let recipients: SessionModel[];

    if (to === 'all') {
      recipients = Array.from(this.participants.values());
    } else {
      recipients = to.map(uuid => this.participants.get(uuid)).filter(Boolean) as SessionModel[];
    }

    for (const recipient of recipients) {
      if (!exclude.has(recipient.uuid)) {
        recipient.forward(action, data);
      }
    }
  }

  /**
   * Forcibly end the room, clearing all participants and states.
   */
  public close(): void {
    // For everyone in the room, we remove their reference to the room
    for (const session of this.participants.values()) {
      session.room = null;
    }

    // Clear all participants, player states, and player map
    this.participants.clear();
    this.playerStates.clear();
    this.playerMap.clear();
  }
}