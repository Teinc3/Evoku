import BiMap from "bidirectional-map";

import MatchHandler from "../../../handlers/match";
import TimeCoordinator from "../../../game/time";
import GameStateController, { LifecycleController } from "../../../game/controllers";

import type { UUID } from "crypto";
import type MatchActions from "@shared/types/enums/actions/match";
import type ActionMap from "@shared/types/actionmap";
import type IDataHandler from "../../../types/handler";
import type BroadcastOptions from "../../../types/broadcast";
import type { SessionModel } from "..";


/**
 * A model representing a room in the game.
 */
export default class RoomModel {
  public readonly stateController: GameStateController;
  public readonly lifecycle: LifecycleController;
  public readonly timeService: TimeCoordinator;
  public readonly roomDataHandler: IDataHandler<MatchActions>

  public participants: Map<UUID, SessionModel>
  public playerMap: BiMap<number>;
  private playerIDCounter: number;
    
  constructor(
    public readonly roomID: string, // Should be generated by RoomManager
    // private readonly actionsLogger: null = null, // TODO: Implement singleton actions logger
    difficulty: "easy" | "medium" | "hard" | "expert" | "impossible" = "easy"
  ) {
    this.roomDataHandler = new MatchHandler(this);
    this.timeService = new TimeCoordinator(this);
    this.stateController = new GameStateController(this.timeService, difficulty);
    this.lifecycle = new LifecycleController(this, this.stateController);

    this.participants = new Map();
    this.playerMap = new BiMap();
    this.playerIDCounter = 0;
  }

  /**
   * Assigns sessions to the room as players.
   * @param sessions The sessions to add to the room, as players.
   */
  public addPlayers(sessions: SessionModel[]): void {
    sessions.forEach(session => {
      // Assign session reference
      this.participants.set(session.uuid, session);
      session.room = this;

      // Create playerID as key
      const playerID = this.playerIDCounter++;
      this.playerMap.set(session.uuid, playerID);
      this.stateController.addPlayer(playerID);
      this.timeService.addPlayerSession(playerID);
    });

    // Notify lifecycle controller that players joined
    this.lifecycle.onPlayerJoined();
  }

  /**
   * Removes a session from the room.
   * @param session The session to remove from the room.
   */
  public removeSession(session: SessionModel): void {
    this.participants.delete(session.uuid);
    const playerID = this.playerMap.get(session.uuid);
    if (playerID !== undefined) {
      this.stateController.removePlayer(playerID);
      this.playerMap.delete(session.uuid);
      this.timeService.removePlayerSession(playerID);
    }
    
    session.room = null; // Dereference the room from the session

    // Notify lifecycle controller that a player left
    this.lifecycle.onPlayerLeft();
  }

  /**
   * Broadcasts data to all sessions in the room.
   * @param action The action to broadcast.
   * @param data The data to send with the action.
   * @optional @param excludeSessions Filter out sessions that should not receive the broadcast.
   */
  public broadcast<GenericAction extends MatchActions>(
    action: GenericAction,
    data: ActionMap[GenericAction],
    options: BroadcastOptions = {}
  ) {
    const { to = 'all', exclude = new Set() } = options;
    let recipients: SessionModel[];

    if (to === 'all') {
      recipients = Array.from(this.participants.values());
    } else {
      recipients = to.map(uuid => this.participants.get(uuid)).filter(Boolean) as SessionModel[];
    }

    for (const recipient of recipients) {
      if (!exclude.has(recipient.uuid)) {
        recipient.forward(action, data);
      }
    }
  }

  /**
   * Helper to resolve a player's numeric ID from a session.
   */
  public getPlayerID(session: SessionModel): number | undefined {
    return this.playerMap.get(session.uuid);
  }

  /**
   * Helper to resolve a session's UUID from a player ID.
   */
  public getSessionIDFromPlayerID(playerID: number): UUID | undefined {
    return this.playerMap.getKey(playerID) as UUID | undefined;
  }

  /**
   * Forcibly end the room, clearing all participants.
   */
  public close(): void {
    // Close the lifecycle controller first
    this.lifecycle.close();
    
    // Close the time service
    this.timeService.close();

    // For everyone in the room, we remove their reference to the room
    for (const session of this.participants.values()) {
      session.room = null;
    }

    // Clear all participants and player map
    this.participants.clear();
    this.playerMap.clear();
  }

  /**
   * Logs action in the room's action logger.
   */
  public logAction(): void {
    // this._actionsLogger.logAction(this.roomID, ...);
  }
}
