import MatchHandler from "../handlers/match";

import type { UUID } from "crypto";
import type PlayerState from "@shared/types/gamestate";
import type MatchActions from "@shared/types/enums/actions/match";
import type ActionMap from "@shared/types/actionmap";
import type IDataHandler from "../types/handler";
import type BroadcastOptions from "../types/broadcast";
import type SessionModel from "./Session";


/**
 * A model representing a room in the game.
 */
export default class RoomModel {
  public roomDataHandler: IDataHandler<MatchActions>
  public participants: Map<UUID, SessionModel>
  private playerStates: Map<number, PlayerState>;
  private playerMap: Map<number, UUID>;
  private playerIDCounter: number;
    
  constructor(
    public readonly roomID: string, // Should be generated by RoomManager
  ) {
    this.roomDataHandler = new MatchHandler(this);
    this.participants = new Map();
    this.playerStates = new Map();
    this.playerMap = new Map();
    this.playerIDCounter = 0;
  }

  /**
   * Assigns sessions to the room as players.
   * @param sessions The sessions to add to the room, as players.
   */
  public addPlayers(sessions: SessionModel[]): void {
    sessions.forEach(session => {
      // Assign session reference
      this.participants.set(session.uuid, session);
      session.room = this;

      // Create playerID as key
      const playerID = this.playerIDCounter++;
      this.playerStates.set(playerID, { playerID });
      this.playerMap.set(playerID, session.uuid);
    });
  }

  /**
   * Removes a session from the room.
   * @param session The session to remove from the room.
   */
  public removeSession(session: SessionModel): void {
    this.participants.delete(session.uuid);
    session.room = null; // Dereference the room from the session

    // Might have to check for / clear game state, and invoke lifecycles
    // For now, we simply remove the state related to the session.
    for (const [playerID, uuid] of this.playerMap.entries()) {
      if (uuid === session.uuid) {
        this.playerMap.delete(playerID);
        // We do not remove the state, as it might be needed for history (like after a game ends)
        break; 
      }
    }
  }

  /**
   * Broadcasts data to all sessions in the room.
   * @param action The action to broadcast.
   * @param data The data to send with the action.
   * @optional @param excludeSessions Filter out sessions that should not receive the broadcast.
   */
  public broadcast<GenericAction extends MatchActions>(
    action: GenericAction,
    data: ActionMap[GenericAction],
    options: BroadcastOptions = {}
  ) {
    const { to = 'all', exclude = new Set() } = options;
    let recepients: SessionModel[];

    if (to === 'all') {
      recepients = Array.from(this.participants.values());
    } else {
      recepients = to.map(uuid => this.participants.get(uuid)).filter(Boolean) as SessionModel[];
    }

    for (const recepient of recepients) {
      if (!exclude.has(recepient.uuid)) {
        recepient.forward(action, data);
      }
    }
  }

}