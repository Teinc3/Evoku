import MatchHandler from "../handlers/match";

import type { UUID } from "crypto";
import type PlayerGameState from "@shared/types/gamestate/PlayerGameState";
import type MatchActions from "@shared/types/enums/actions/match";
import type ActionMap from "@shared/types/actionmap";
import type IDataHandler from "../types/handler";
import type BroadcastOptions from "../types/broadcast";
import type SessionModel from "./Session";


/**
 * A model representing a room in the game.
 */
export default class RoomModel {
  public participants: Map<UUID, SessionModel>
  public roomDataHandler: IDataHandler<MatchActions>
  private playerStates: Map<number, PlayerGameState>;
  private playerIDCounter: number;
    
  constructor(
    public readonly roomID: string, // Should be generated by RoomManager
  ) {
    this.participants = new Map();
    this.roomDataHandler = new MatchHandler(this);
    this.playerStates = new Map();
    this.playerIDCounter = 0;
  }

  /**
   * Assigns sessions to the room as players.
   * @param sessions The sessions to add to the room, as players.
   */
  public addPlayers(sessions: SessionModel[], _spectator: boolean = false): void {
    sessions.forEach(session => {
      this.participants.set(session.uuid, session);
      session.room = this;
      /* session.gameState = new GameStateModel(
        playerID = this.playerIDCounter++,
      )*/
    });
  }

  /**
   * Removes a session from the room.
   * @param session The session to remove from the room.
   */
  public removeSession(session: SessionModel): void {
    this.participants.delete(session.uuid);
    session.room = null; // Clear the room for the session

    // Might have to check for / clear game state, and invoke lifecycles
  }

  /**
   * Broadcasts data to all sessions in the room.
   * @param action The action to broadcast.
   * @param data The data to send with the action.
   * @optional @param excludeSessions Filter out sessions that should not receive the broadcast.
   */
  public broadcast<GenericAction extends MatchActions>(
    action: GenericAction,
    data: ActionMap[GenericAction],
    options: BroadcastOptions = {}
  ) {
    const { to = 'all', exclude = new Set() } = options;
    let recepients: SessionModel[];

    if (to === 'all') {
      recepients = Array.from(this.participants.values());
    } else {
      recepients = to.map(uuid => this.participants.get(uuid)).filter(Boolean) as SessionModel[];
    }

    for (const recepient of recepients) {
      if (!exclude.has(recepient.uuid)) {
        recepient.forward(action, data);
      }
    }
  }

}